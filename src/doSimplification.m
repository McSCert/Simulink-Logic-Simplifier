function [finalEqus, baseEqus] = doSimplification(sys, blocks, varargin)
    % DOSIMPLIFICATION Performs simplification on the input blocks.
    %
    % Inputs:
    % 	sys         Handle of empty system to place the simplified blocks in.
    %   blocks      List of blocks to perform simplification on.
    %   varargin    See "Initializations" in the code.
    %
    % Outputs:
    % 	baseEqus    Equations extracted from blocks for simplification.
    %   finalEqus   Equations generated by simplifying the starting equations to
    %               use to build a simpler model.
    
    %% Initializations
    subsystem_rule = 'blackbox'; % Default
    extraSupportFun = @defaultExtraSupport;
    generate_mode = 'All';
    blocks_to_simplify = 'selected';
    startSys = ''; % Will always be updated before first use
    assert(mod(length(varargin),2) == 0, 'Even number of varargin arguments expected.')
    for i = 1:2:length(varargin)
        param = lower(varargin{i});
        value = varargin{i+1};
        
        switch param
            case 'subsystem_rule'
                subsystem_rule = value;
            case 'extra_support_function'
                assert(exist(value, 'file') == 2, ...
                    'Error: extra_support_function in the config is expected to be a file on the MATLAB path.')
                extraSupportFun = eval(['@' value]);
            case 'generate_mode'
                assert(any(strcmpi(value, {'SimplifiedOnly', 'All'})), ...
                    'Unexpected parameter value.')
                generate_mode = value;
            case 'blocks_to_simplify'
                assert(any(strcmpi(value, {'Selected', 'Unselected'})), ...
                    'Unexpected parameter value.')
                blocks_to_simplify = value;
            case 'startsys'
                assert(ischar(value), 'Unexpected parameter value.')
                startSys = value; % Gets reset unless blocks is empty
            otherwise
                error(['Error in ' mfilename ' unexpected Name for Name-Value pair input argument.'])
        end
    end
    
    endSys = getfullname(sys);
    if ~isempty(blocks)
        assert(all(strcmp(get_param(blocks{1}, 'Parent'), get_param(blocks,'Parent'))), ['Error in ' mfilename ', all blocks must be in the same system.'])
        startSys = get_param(blocks{1}, 'Parent');
    else
        assert(~strcmp(startSys, ''), ['Error in ' mfilename ', must pass startSys parameter if blocks argument is empty.'])
    end
    
    
    % Keep a list of blocks/ports that we have equations for
    %   Note: handles are 'lookup' keys, and string identifiers are 'lookdown' keys
    lhsTable = BiMap('double','char');
    
    %% Get block lists
    % blocks - blocks to simplify
    % sysBlocks - blocks to simplify and blocks to simplify around
    
    topSysBlocks = find_system(startSys, 'SearchDepth', '1');
    topSysBlocks = topSysBlocks(2:end); % Remove startSys
    
    % Get block list including blocks from the top-level and ones from nested
    % levels depending on the subsystem_rule parameter.
    sysBlocks = topSysBlocks;
    if strcmp(blocks_to_simplify, 'selected')
        % Do nothing
    elseif strcmp(blocks_to_simplify, 'unselected')
        blocks = setdiff(topSysBlocks, blocks);
    else
        error('Error, invalid blocks_to_simplify')
    end
    if strcmp(subsystem_rule, 'full-simplify') || strcmp(subsystem_rule, 'part-simplify')
        % All blocks in subsystems of blocks should be included as blocks to
        % simplify
        
        tmpBlocks = blocks; % use temp variable so indices aren't messed up
        for i = 1:length(blocks)
            % Note this loop uses blocks not sysBlocks, we want sysBlocks to involve
            % all blocks in any subsystem being modified, we only want to
            % modify subsystems in blocks.
            if strcmp(get_param(blocks{i}, 'BlockType'), 'SubSystem') ...
                    && strcmp(get_param(blocks{i}, 'Mask'), 'off')
                subBlocks = find_system(blocks{i});
                assert(~isempty(subBlocks),'Temporary assertion for debugging.') % TODO remove this
                sysBlocks = union(sysBlocks, subBlocks);
                tmpBlocks = union(tmpBlocks, subBlocks);
            end
        end
        blocks = tmpBlocks;
    elseif strcmp(subsystem_rule, 'blackbox')
        % No changes needed. We aren't simplifying within subsystems.
    else
        error('Error, invalid subsystem_rule')
    end
    
    %% Get starting equations
    %   Expected form: 'handleID = expr' or 'handleID =? expr'
    %   'handleID' is a char used to identify a Simulink object
    %   '=?' indicates the equation is blackbox; only the interface is known
    %   expr is an expression using {<,<=,>,>=,==,~=,&,|}
    baseEqus = getEqusForBlocks(startSys, blocks, sysBlocks, lhsTable, subsystem_rule, extraSupportFun);
    
    %% Substitute equations
    %   Substitute to get rid of extranneous equations before simplification
    preSimpleEqus = substituteEqus(baseEqus, blocks, lhsTable, subsystem_rule);
    
    %% Simplify expressions
    postSimpleEqus = cell(1,length(preSimpleEqus));
    for i = 1:length(preSimpleEqus)
        if ~isBlackBoxEquation(preSimpleEqus{i})
            [lhs, rhs] = getEquationLhsRhs(preSimpleEqus{i});
            
            % TODO
            %Swap Chrysler's CbTRUE for symengine's TRUE
            %         rhs = strrep(rhs, 'CbTRUE', 'TRUE');
            %         rhs = strrep(rhs, 'CbFALSE', 'FALSE');
            
            %Do the simplification
            simpleRhs = simplifyExpression(rhs);
            
            %Strip whitespace
            simpleRhs = regexprep(simpleRhs, '\s', '');
            postSimpleEqus{i} = [lhs, ' = ', simpleRhs];
        else
            postSimpleEqus{i} = preSimpleEqus{i};
        end
    end
    
    %% Create blocks for each equation
    s2e_blockHandles = createEquations(postSimpleEqus, lhsTable, startSys, endSys, subsystem_rule);
    
    %
    unselectedBlocks = setdiff(topSysBlocks,blocks);
    unselectedBlocksHdls = get_param(unselectedBlocks,'Handle');
    e_unselected_handles = [];
    for i = 1:length(unselectedBlocksHdls)
        % For all blocks that weren't selected at top-level
        
        % Search for a corresponding end block
        if s2e_blockHandles.isKey(unselectedBlocksHdls{i})
            e_unselected_handles(end+1) = s2e_blockHandles(unselectedBlocksHdls{i});
        end
    end
    
    % Swap block patterns for simpler ones
    e_handles = find_system(endSys, 'SearchDepth', 1, 'FindAll', 'on', 'Type', 'Block');
    e_selected_handles = setdiff(e_handles, e_unselected_handles);
    % (This will only swap blocks on the top-level)
    swapBlockPattern(endSys, e_selected_handles, extraSupportFun);
    
    %
    if strcmpi(generate_mode, 'simplifiedonly')
        % Delete end blocks of start blocks that weren't selected
        for i = 1:length(e_unselected_handles)
            % Delete block and its lines
            delete_block_lines(e_unselected_handles(i))
            delete_block(e_unselected_handles(i))
        end
    elseif ~strcmpi(generate_mode, 'All')
        error('Unexpected parameter value.')
    end
    
    %
    e_handles = find_system(endSys, 'SearchDepth', 1, 'FindAll', 'on', 'Type', 'Block');
    e_selected_handles = setdiff(e_handles, e_unselected_handles);
    removedBlocks = RemoveSimulinkDuplicates(e_selected_handles, 'DeleteDuplicateBlocks', 'on');
    e_selected_handles = setdiff(e_selected_handles, removedBlocks);
    
    %
    addedBlocks = branching2multiple(e_selected_handles, {'From', 'DataStoreRead', 'Constant'});
    e_selected_handles = union(e_selected_handles, addedBlocks);
    
    %
    finalEqus = postSimpleEqus;
    
    % Auto Layout the simplified blocks
    automatic_layout(e_selected_handles, inputToCell(blocks))
    
    % Reorder inputs of Logic blocks, == blocks, and ~= blocks to improve line
    % routing.
    logicBlocks = find_blocks(e_selected_handles, 'BlockType', 'Logic');
    eqBlocks = find_blocks(e_selected_handles, 'BlockType', 'RelationalOperator', 'Operator', '==');
    neqBlocks = find_blocks(e_selected_handles, 'BlockType', 'RelationalOperator', 'Operator', '~=');
    commutativeBlocks = union(union(logicBlocks, eqBlocks), neqBlocks);
    for i = 1:length(commutativeBlocks)
        cBlockName = getfullname(commutativeBlocks(i));
        ReorderInputs(cBlockName);
    end
    automatic_layout(e_selected_handles, inputToCell(blocks))
    % The following will undo line routing done previously by automatic_layout.
    blockLines = get_block_lines(e_handles); % Lines connected to the given blocks
    automatic_line_routing(blockLines);
    
    % Select simplified blocks
    for i = 1:length(e_selected_handles)
        set_param(e_selected_handles(i), 'Selected', 'on')
    end
    
end

function automatic_layout(objs, old_objs)
    startBounds = bounds_of_sim_objects(old_objs);
    try
        AutoLayout(objs, 'LayoutStartBounds', startBounds, 'ShiftAll', 'on'); % This is an AutoLayout function
    catch ME
        warning(['Error occurred in AutoLayout. ' ...
            mfilename ' continuing without automatic layout' ...
            '. The error message follows:' char(10) getReport(ME)])
    end
end

function automatic_line_routing(blockLines)
    try
        autolayout_lines(blockLines); % This is an AutoLayout function
    catch ME
        warning(['Error occurred in AutoLayout''s line routing. ' ...
            mfilename ' continuing anyway' ...
            '. The error message follows:' char(10) getReport(ME)])
    end
end

function atomics = copySystemInports(startSys, endSys, atomics, predicates)
    inports = find_system(startSys, 'SearchDepth', 1, 'BlockType', 'Inport'); % List of inports in the system
    for i = 1:length(inports)
        ports = get_param(inports{i}, 'PortHandles');
        dstPort = ports.Outport;
        assert(length(dstPort) == 1, 'Unexpected number of outports on block.')
        
        assert(strcmp(startSys, get_param(block, 'Parent')))
        newIn = copy_block(inports{i}, endSys);
        
        if isKey(predicates, dstPort)
            equationID = predicates(dstPort); % ID used to refer to this block in equations
            atomics(equationID) = newIn;
        end % else the inport isn't used
    end
end

function atomics = copySystemSubSystems(startSys, endSys, atomics, predicates)
    subsystems = find_system(startSys, 'SearchDepth', 1, 'BlockType', 'SubSystem', 'Parent', startSys); % List of SubSystems in the system
    for i = 1:length(subsystems)
        newBlock = regexprep(subsystems{i},['^' startSys], endSys, 'ONCE');
        newSub = add_block(subsystems{i}, newBlock);
        
        oldSubOutports = get_param(subsystems{i}, 'PortHandles');
        oldSubOutports = oldSubOutports.Outport;
        
        subOutports = get_param(newSub, 'PortHandles');
        subOutports = subOutports.Outport;
        
        assert(length(oldSubOutports) == length(subOutports))
        for j = 1:length(subOutports)
            if isKey(predicates, oldSubOutports(j))
                equationID = predicates(oldSubOutports(j));
                atomics(equationID) = subOutports(j);
            end
        end
    end
end

function atomics = copyBlackBoxes(startSys, endSys, atomics, predicates, blackBoxes)
    for i = 1:length(blackBoxes)
        newBlock = regexprep(blackBoxes{i},['^' startSys], endSys, 'ONCE');
        newBB = add_block(blackBoxes{i}, newBlock);
        
        oldBBOutports = get_param(blackBoxes{i}, 'PortHandles');
        oldBBOutports = oldBBOutports.Outport;
        
        BBOutports = get_param(newBB, 'PortHandles');
        BBOutports = BBOutports.Outport;
        
        assert(length(oldBBOutports) == length(BBOutports))
        for j = 1:length(BBOutports)
            if isKey(predicates, oldBBOutports(j))
                equationID = predicates(oldBBOutports(j));
                atomics(equationID) = BBOutports(j);
            end
        end
    end
end

function blocks = find_blocks(allBlocks, varargin)
    % allBlocks - vector of block handles.
    % varargin - parameter-value pairs
    % blocks - blocks in allBlocks satisfying each parameter value pair in
    %   order (order of parameters is relevant for avoiding errors)
    
    allBlocks = inputToNumeric(allBlocks);
    blocks = [];
    for i = 1:length(allBlocks)
        blockPassing = true; % Current status of whether or not a block satisfies the conditions indicated by varargin.
        for j = 1:2:length(varargin)
            param = varargin{j};
            desiredValue = varargin{j+1};
            value = get_param(allBlocks(i), param);
            % Check if value is the expected value (converts num to string if
            % one is a num and the other a string).
            if isnumeric(value)
                if isnumeric(desiredValue)
                    if value ~= desiredValue
                        blockPassing = false;
                        break
                    end
                elseif ischar(desiredValue)
                    if ~strcmp(num2str(value), desiredValue)
                        blockPassing = false;
                        break
                    end
                else
                    error('Case unhandled.')
                end
            elseif ischar(value)
                if isnumeric(desiredValue)
                    if ~strcmp(value, num2str(desiredValue))
                        blockPassing = false;
                        break
                    end
                elseif ischar(desiredValue)
                    if ~strcmp(value, desiredValue)
                        blockPassing = false;
                        break
                    end
                else
                    error('Case unhandled.')
                end
            else
                error('Case unhandled.')
            end
        end
        if blockPassing
            blocks(end+1) = allBlocks(i);
        end
    end
end